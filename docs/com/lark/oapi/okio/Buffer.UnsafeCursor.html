<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_301) on Wed Sep 07 14:59:31 CST 2022 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Buffer.UnsafeCursor (larksuite-oapi 2.0.2-rc3 API)</title>
<meta name="date" content="2022-09-07">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Buffer.UnsafeCursor (larksuite-oapi 2.0.2-rc3 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10};
var tabs = {65535:["t0","所有方法"],2:["t2","实例方法"],8:["t4","具体方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Buffer.UnsafeCursor.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../../index-all.html">索引</a></li>
<li><a href="../../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/lark/oapi/okio/Buffer.html" title="com.lark.oapi.okio中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../../com/lark/oapi/okio/BufferedSink.html" title="com.lark.oapi.okio中的接口"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/lark/oapi/okio/Buffer.UnsafeCursor.html" target="_top">框架</a></li>
<li><a href="Buffer.UnsafeCursor.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.lark.oapi.okio</div>
<h2 title="类 Buffer.UnsafeCursor" class="title">类 Buffer.UnsafeCursor</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="java.lang中的类或接口">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>com.lark.oapi.okio.Buffer.UnsafeCursor</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>所有已实现的接口:</dt>
<dd><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html?is-external=true" title="java.io中的类或接口">Closeable</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true" title="java.lang中的类或接口">AutoCloseable</a></dd>
</dl>
<dl>
<dt>封闭类:</dt>
<dd><a href="../../../../com/lark/oapi/okio/Buffer.html" title="com.lark.oapi.okio中的类">Buffer</a></dd>
</dl>
<hr>
<br>
<pre>public static final class <span class="typeNameLabel">Buffer.UnsafeCursor</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="java.lang中的类或接口">Object</a>
implements <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html?is-external=true" title="java.io中的类或接口">Closeable</a></pre>
<div class="block">A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce
 its own invariants. Instead, it assumes a careful user who has studied Okio's implementation
 details and their consequences.

 <h3>Buffer Internals</h3>

 <p>Most code should use <code>Buffer</code> as a black box: a class that holds 0 or more bytes of
 data with efficient APIs to append data to the end and to consume data from the front. Usually
 this is also the most efficient way to use buffers because it allows Okio to employ several
 optimizations, including:

 <ul>
   <li><strong>Fast Allocation:</strong> Buffers use a shared pool of memory that is not
       zero-filled before use.
   <li><strong>Fast Resize:</strong> A buffer's capacity can change without copying its
       contents.
   <li><strong>Fast Move:</strong> Memory ownership can be reassigned from one buffer to
       another.
   <li><strong>Fast Copy:</strong> Multiple buffers can share the same underlying memory.
   <li><strong>Fast Encoding and Decoding:</strong> Common operations like UTF-8 encoding and
       decimal decoding do not require intermediate objects to be allocated.
 </ul>

 <p>These optimizations all leverage the way Okio stores data internally. Okio Buffers are
 implemented using a doubly-linked list of segments. Each segment is a contiguous range within a
 8 KiB <code>byte[]</code>. Each segment has two indexes, <code>start</code>, the offset of the first
 byte of the array containing application data, and <code>end</code>, the offset of the first byte
 beyond <code>start</code> whose data is undefined.

 <p>New buffers are empty and have no segments:

 <pre>   <code>

   Buffer buffer = new Buffer();
 </code></pre>
 <p>
 We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a
 segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7
 bytes of data:

 <pre>   <code>

   buffer.writeUtf8("sealion");

   // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...]
   //    ^                                  ^
   // start = 0                          end = 7
 </code></pre>
 <p>
 When we read 4 bytes of data from the buffer, it finds its first segment and returns that data
 to us. As bytes are read the data is consumed. The segment tracks this by adjusting its
 internal indices.

 <pre>   <code>

   buffer.readUtf8(4); // "seal"

   // [ 's', 'e', 'a', 'l', 'i', 'o', 'n', '?', '?', '?', ...]
   //                        ^              ^
   //                     start = 4      end = 7
 </code></pre>
 <p>
 As we write data into a buffer we fill up its internal segments. When a write doesn't fit into
 a buffer's last segment, additional segments are allocated and appended to the linked list of
 segments. Each segment has its own start and end indexes tracking where the user's data begins
 and ends.

 <pre>   <code>

   Buffer xoxo = new Buffer();
   xoxo.writeUtf8(Strings.repeat("xo", 5_000));

   // [ 'x', 'o', 'x', 'o', 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o']
   //    ^                                                               ^
   // start = 0                                                      end = 8192
   //
   // [ 'x', 'o', 'x', 'o', ..., 'x', 'o', 'x', 'o', '?', '?', '?', ...]
   //    ^                                            ^
   // start = 0                                   end = 1808
 </code></pre>
 <p>
 The start index is always <strong>inclusive</strong> and the end index is always
 <strong>exclusive</strong>. The data preceding the start index is undefined, and the data
 at and following the end index is undefined.

 <p>After the last byte of a segment has been read, that segment may be returned to an internal
 segment pool. In addition to reducing the need to do garbage collection, segment pooling also
 saves the JVM from needing to zero-fill byte arrays. Okio doesn't need to zero-fill its arrays
 because it always writes memory before it reads it. But if you look at a segment in a debugger
 you may see its effects. In this example, one of the "xoxo" segments above is reused in an
 unrelated buffer:

 <pre>   <code>

   Buffer abc = new Buffer();
   abc.writeUtf8("abc");

   // [ 'a', 'b', 'c', 'o', 'x', 'o', 'x', 'o', ...]
   //    ^              ^
   // start = 0     end = 3
 </code></pre>
 <p>
 There is an optimization in <code>Buffer.clone()</code> and other methods that allows two segments
 to share the same underlying byte array. Clones can't write to the shared byte array; instead
 they allocate a new (private) segment early.

 <pre>   <code>

   Buffer nana = new Buffer();
   nana.writeUtf8(Strings.repeat("na", 2_500));
   nana.readUtf8(2); // "na"

   // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...]
   //              ^                                  ^
   //           start = 0                         end = 5000

   nana2 = nana.clone();
   nana2.writeUtf8("batman");

   // [ 'n', 'a', 'n', 'a', ..., 'n', 'a', 'n', 'a', '?', '?', '?', ...]
   //              ^                                  ^
   //           start = 0                         end = 5000
   //
   // [ 'b', 'a', 't', 'm', 'a', 'n', '?', '?', '?', ...]
   //    ^                             ^
   //  start = 0                    end = 7
 </code></pre>
 <p>
 Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended
 to prevent fragmentation in sharing-heavy use cases.

 <h3>Unsafe Cursor API</h3>

 <p>This class exposes privileged access to the internal byte arrays of a buffer. A cursor
 either references the data of a single segment, it is before the first segment (<code>offset == -1</code>), or it is after the last segment (<code>offset == buffer.size</code>).

 <p>Call <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#seek-long-"><code>seek(long)</code></a> to move the cursor to the segment that contains a specified offset. After
 seeking, <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#data"><code>data</code></a> references the segment's internal byte array, <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#start"><code>start</code></a> is the
 segment's start and <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#end"><code>end</code></a> is its end.

 <p>Call <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#next--"><code>next()</code></a> to advance the cursor to the next segment. This returns -1 if there are
 no further segments in the buffer.

 <p>Use <a href="../../../../com/lark/oapi/okio/Buffer.html#readUnsafe--"><code>Buffer.readUnsafe()</code></a> to create a cursor to read buffer data and <a href="../../../../com/lark/oapi/okio/Buffer.html#readAndWriteUnsafe--"><code>Buffer.readAndWriteUnsafe()</code></a> to create a cursor to read and write buffer data. In either case,
 always call <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#close--"><code>close()</code></a> when done with a cursor. This is convenient with Java 7's
 try-with-resources syntax. In this example we read all of the bytes in a buffer into a byte
 array:

 <pre>   <code>

   byte[] bufferBytes = new byte[(int) buffer.size()];

   try (UnsafeCursor cursor = buffer.readUnsafe()) {
     while (cursor.next() != -1) {
       System.arraycopy(cursor.data, cursor.start,
           bufferBytes, (int) cursor.offset, cursor.end - cursor.start);
     }
   }
 </code></pre>

 <p>Change the capacity of a buffer with <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#resizeBuffer-long-"><code>resizeBuffer(long)</code></a>. This is only permitted for
 read+write cursors. The buffer's size always changes from the end: shrinking it removes bytes
 from the end; growing it adds capacity to the end.

 <h3>Warnings</h3>

 <p>Most application developers should avoid this API. Those that must use this API should
 respect these warnings.

 <p><strong>Don't mutate a cursor.</strong> This class has public, non-final fields because that
 is convenient for low-level I/O frameworks. Never assign values to these fields; instead use
 the cursor API to adjust these.

 <p><strong>Never mutate <code>data</code> unless you have read+write access.</strong> You are on the
 honor system to never write the buffer in read-only mode. Read-only mode may be more efficient
 than read+write mode because it does not need to make private copies of shared segments.

 <p><strong>Only access data in <code>[start..end)</code>.</strong> Other data in the byte array
 is undefined! It may contain private or sensitive data from other parts of your process.

 <p><strong>Always fill the new capacity when you grow a buffer.</strong> New capacity is not
 zero-filled and may contain data from other parts of your process. Avoid leaking this
 information by always writing something to the newly-allocated capacity. Do not assume that
 new capacity will be filled with <code>0</code>; it will not be.

 <p><strong>Do not access a buffer while is being accessed by a cursor.</strong> Even simple
 read-only operations like <a href="../../../../com/lark/oapi/okio/Buffer.html#clone--"><code>Buffer.clone()</code></a> are unsafe because they mark segments as shared.

 <p><strong>Do not hard-code the segment size in your application.</strong> It is possible that
 segment sizes will change with advances in hardware. Future versions of Okio may even have
 heterogeneous segment sizes.

 <p>These warnings are intended to help you to use this API safely. It's here for developers
 that need absolutely the most throughput. Since that's you, here's one final performance tip.
 You can reuse instances of this class if you like. Use the overloads of <a href="../../../../com/lark/oapi/okio/Buffer.html#readUnsafe--"><code>Buffer.readUnsafe()</code></a> and
 <a href="../../../../com/lark/oapi/okio/Buffer.html#readAndWriteUnsafe--"><code>Buffer.readAndWriteUnsafe()</code></a> that take a cursor and close it after use.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>字段概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="字段概要表, 列表字段和解释">
<caption><span>字段</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">字段和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../com/lark/oapi/okio/Buffer.html" title="com.lark.oapi.okio中的类">Buffer</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#buffer">buffer</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#data">data</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#end">end</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#offset">offset</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#readWrite">readWrite</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#start">start</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#UnsafeCursor--">UnsafeCursor</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#close--">close</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#expandBuffer-int-">expandBuffer</a></span>(int&nbsp;minByteCount)</code>
<div class="block">Grow the buffer by adding a <strong>contiguous range</strong> of capacity in a single
 segment.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#next--">next</a></span>()</code>
<div class="block">Seeks to the next range of bytes, advancing the offset by <code>end - start</code>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#resizeBuffer-long-">resizeBuffer</a></span>(long&nbsp;newSize)</code>
<div class="block">Change the size of the buffer so that it equals <code>newSize</code> by either adding new capacity
 at the end or truncating the buffer at the end.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#seek-long-">seek</a></span>(long&nbsp;offset)</code>
<div class="block">Reposition the cursor so that the data at <code>offset</code> is readable at <code>data[start]</code>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="java.lang中的类或接口">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="java.lang中的类或接口">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#getClass--" title="java.lang中的类或接口">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="java.lang中的类或接口">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notify--" title="java.lang中的类或接口">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="java.lang中的类或接口">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#toString--" title="java.lang中的类或接口">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait--" title="java.lang中的类或接口">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="java.lang中的类或接口">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="java.lang中的类或接口">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>字段详细资料</h3>
<a name="buffer">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public&nbsp;<a href="../../../../com/lark/oapi/okio/Buffer.html" title="com.lark.oapi.okio中的类">Buffer</a> buffer</pre>
</li>
</ul>
<a name="readWrite">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readWrite</h4>
<pre>public&nbsp;boolean readWrite</pre>
</li>
</ul>
<a name="offset">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>offset</h4>
<pre>public&nbsp;long offset</pre>
</li>
</ul>
<a name="data">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>data</h4>
<pre>public&nbsp;byte[] data</pre>
</li>
</ul>
<a name="start">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>start</h4>
<pre>public&nbsp;int start</pre>
</li>
</ul>
<a name="end">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>end</h4>
<pre>public&nbsp;int end</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="UnsafeCursor--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>UnsafeCursor</h4>
<pre>public&nbsp;UnsafeCursor()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="next--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre>public final&nbsp;int&nbsp;next()</pre>
<div class="block">Seeks to the next range of bytes, advancing the offset by <code>end - start</code>. Returns the
 size of the readable range (at least 1), or -1 if we have reached the end of the buffer and
 there are no more bytes to read.</div>
</li>
</ul>
<a name="seek-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>seek</h4>
<pre>public final&nbsp;int&nbsp;seek(long&nbsp;offset)</pre>
<div class="block">Reposition the cursor so that the data at <code>offset</code> is readable at <code>data[start]</code>.
 Returns the number of bytes readable in <code>data</code> (at least 1), or -1 if there are no data
 to read.</div>
</li>
</ul>
<a name="resizeBuffer-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resizeBuffer</h4>
<pre>public final&nbsp;long&nbsp;resizeBuffer(long&nbsp;newSize)</pre>
<div class="block">Change the size of the buffer so that it equals <code>newSize</code> by either adding new capacity
 at the end or truncating the buffer at the end. Newly added capacity may span multiple
 segments.

 <p>As a side-effect this cursor will <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#seek-long-"><code>seek</code></a>. If the buffer is being enlarged it
 will move <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#offset"><code>offset</code></a> to the first byte of newly-added capacity. This is the size of the
 buffer prior to the <code>resizeBuffer()</code> call. If the buffer is being shrunk it will move
 <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#offset"><code>offset</code></a> to the end of the buffer.

 <p>Warning: it is the caller’s responsibility to write new data to every byte of the
 newly-allocated capacity. Failure to do so may cause serious security problems as the data in
 the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold
 very sensitive data from other parts of the current process.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the previous size of the buffer.</dd>
</dl>
</li>
</ul>
<a name="expandBuffer-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expandBuffer</h4>
<pre>public final&nbsp;long&nbsp;expandBuffer(int&nbsp;minByteCount)</pre>
<div class="block">Grow the buffer by adding a <strong>contiguous range</strong> of capacity in a single
 segment. This adds at least <code>minByteCount</code> bytes but may add up to a full segment of
 additional capacity.

 <p>As a side-effect this cursor will <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#seek-long-"><code>seek</code></a>. It will move <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#offset"><code>offset</code></a> to the
 first byte of newly-added capacity. This is the size of the buffer prior to the <code>expandBuffer()</code> call.

 <p>If <code>minByteCount</code> bytes are available in the buffer's current tail segment that
 will be used; otherwise another segment will be allocated and appended. In either case this
 returns the number of bytes of capacity added to this buffer.

 <p>Warning: it is the caller’s responsibility to either write new data to every byte of the
 newly-allocated capacity, or to <a href="../../../../com/lark/oapi/okio/Buffer.UnsafeCursor.html#resizeBuffer-long-"><code>shrink</code></a> the buffer to the data written.
 Failure to do so may cause serious security problems as the data in the returned buffers is
 not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from
 other parts of the current process.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>minByteCount</code> - the size of the contiguous capacity. Must be positive and not greater
                     than the capacity size of a single segment (8 KiB).</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the number of bytes expanded by. Not less than <code>minByteCount</code>.</dd>
</dl>
</li>
</ul>
<a name="close--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>close</h4>
<pre>public&nbsp;void&nbsp;close()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html?is-external=true#close--" title="java.io中的类或接口">close</a></code>&nbsp;在接口中&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html?is-external=true" title="java.io中的类或接口">Closeable</a></code></dd>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true#close--" title="java.lang中的类或接口">close</a></code>&nbsp;在接口中&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true" title="java.lang中的类或接口">AutoCloseable</a></code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Buffer.UnsafeCursor.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../../index-all.html">索引</a></li>
<li><a href="../../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/lark/oapi/okio/Buffer.html" title="com.lark.oapi.okio中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../../com/lark/oapi/okio/BufferedSink.html" title="com.lark.oapi.okio中的接口"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/lark/oapi/okio/Buffer.UnsafeCursor.html" target="_top">框架</a></li>
<li><a href="Buffer.UnsafeCursor.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2022. All rights reserved.</small></p>
</body>
</html>
